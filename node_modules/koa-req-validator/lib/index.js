'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = validate;

var _validator = require('validator');

var _validator2 = _interopRequireDefault(_validator);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toArray(arr) { return Array.isArray(arr) ? arr : Array.from(arr); }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

const REGEXP = /(.*)\((.*)\)/;
const SCOPES = ['params', 'query', 'body'];

function validate(rules) {
  let runCheck = (() => {
    var _ref2 = _asyncToGenerator(function* (check, value) {
      const args = [value];
      const match = check.match(REGEXP);

      if (match) {
        check = match[1];
        match[2].split(',').map(function (v) {
          return JSON.parse(v);
        }).forEach(function (v) {
          return args.push(v);
        });
      }

      // Treats null-empthy specially: ok unless require or isRequired is specified
      const hasNoValue = isNullOrEmpty(value);
      if (~['require', 'isRequired'].indexOf(check)) {
        return !hasNoValue;
      } else if (hasNoValue) {
        return true;
      }

      if (!_validator2.default[check]) {
        throw new Error(`Rule '${check}' does not exist`);
      }

      return yield _validator2.default[check].apply(_validator2.default, args);
    });

    return function runCheck(_x3, _x4) {
      return _ref2.apply(this, arguments);
    };
  })();

  return (() => {
    var _ref = _asyncToGenerator(function* (ctx, next) {
      const errors = [];

      for (let field of Object.keys(rules)) {
        const fieldRules = rules[field];
        const fieldValue = getFieldValue(ctx, field);
        const message = fieldRules[fieldRules.length - 1];
        const checks = fieldRules.slice(0, -1);

        for (let check of checks) {
          const isValid = yield runCheck(check, fieldValue);
          if (!isValid) {
            errors.push(message);
            break;
          }
        }
      }

      if (errors.length) {
        ctx.throw(errors.join('; '), 400);
      } else if (next) {
        yield next();
      }
    });

    return function (_x, _x2) {
      return _ref.apply(this, arguments);
    };
  })();

  function getFieldValue(ctx, field) {
    var _field$split = field.split(':'),
        _field$split2 = _toArray(_field$split);

    let name = _field$split2[0],
        scopes = _field$split2.slice(1);

    if (scopes.length === 0) {
      scopes = SCOPES;
    }

    for (let scope of scopes) {
      if (!~SCOPES.indexOf(scope)) {
        throw new Error(`Invalid scope, must be one of ${SCOPES.join(', ')}`);
      }

      const value = scope === 'params' ? getValueByPath(ctx.params, name) : scope === 'query' ? getValueByPath(ctx.request.query, name) : ctx.request.body && getValueByPath(ctx.request.body, name);

      if (value != null) {
        return value;
      }
    }
  }

  function getValueByPath(obj, path) {
    return path.indexOf('.') === -1 ? obj[path] : path.split('.').reduce((res, prop) => isObject(res) ? res[prop] : undefined, obj);
  }

  function isObject(obj) {
    return Object.prototype.toString.call(obj) === '[object Object]';
  }

  function isNullOrEmpty(str) {
    return str == null || str === '' || typeof str === 'string' && str.trim() === '';
  }
}